<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hologram Effect</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #000;
        }
        .id_image_data {
            position: relative;
            width: 100%;
            max-width: 800px;
        }
        .id_image {
            width: 100%;
            display: block;
        }
        .background-hologram-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        .inset {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 50%;
            height: 50%;
            background-color: rgba(255, 255, 255, 0.5);
        }
        .id_own_image {
            position: absolute;
            top: 50px;
            left: 50px;
            width: 200px;
            height: 200px;
            background-size: cover;
        }
        .flag_video {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 100px;
            height: 100px;
        }
    </style>
</head>
<body>
    <div class="id_image_data">
        <img draggable="false" class="id_image" src="images/XSZFxrl.png">
        <canvas id="backgroundHologramCanvas" class="background-hologram-overlay"></canvas>
        <div class="inset"></div>
        <div class="id_own_image" style="background-image: url('https://i.imgur.com/7vHo48p.jpg');"></div>
        <img draggable="false" src="images/gzot1Pt.gif" class="flag_video">
    </div>

    <script>
        // Get canvas and WebGL context
        let backgroundHologramCanvas = document.getElementById('backgroundHologramCanvas');
        let backgroundHologramGl = backgroundHologramCanvas.getContext('webgl');

        // Load texture for mid_background_main_dynamic
        function loadBackgroundHologramTexture(gl) {
            const texture = gl.createTexture();
            const image = new Image();
            image.crossOrigin = 'anonymous';
            image.src = 'https://hebbkx1anhila5yf.public.blob.vercel-storage.com/mid_background_main_dynamic-fRoe4ezU4pibmjf6PNKfZoIeMFQaVa.webp';
            image.onload = function() {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            };
            return texture;
        }

        // Vertex shader source code
        const vertexShaderSource = `
            attribute vec2 a_position;
            attribute vec2 a_textureCoordinates;
            attribute vec2 a_accelerometerCoordinates;

            varying vec2 v_TextureCoordinates;
            varying vec2 v_AccelerometerCoordinates;

            void main() {
                v_TextureCoordinates = a_textureCoordinates;
                v_AccelerometerCoordinates = a_accelerometerCoordinates;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // Fragment shader source code
        const fragmentShaderSource = `
            precision mediump float;

            uniform sampler2D u_BackgroundTexture;
            uniform sampler2D u_HologramTexture;
            uniform sampler2D u_HoloMapTexture;
            uniform sampler2D u_EagleTexture;
            uniform sampler2D u_HoloLayerTexture;
            uniform sampler2D u_BackgroundHologramTexture;

            varying vec2 v_TextureCoordinates;
            varying vec2 v_AccelerometerCoordinates;

            void main() {
                vec2 redAccelerometerCoordinates = v_AccelerometerCoordinates + 0.1 * v_TextureCoordinates;
                vec2 greenAccelerometerCoordinates = v_AccelerometerCoordinates + vec2(0.333, -0.333) + 0.1 * v_TextureCoordinates;
                vec2 blueAccelerometerCoordinates = v_AccelerometerCoordinates + vec2(0.667, -0.667) + 0.1 * v_TextureCoordinates;

                vec3 backgroundColor = texture2D(u_BackgroundTexture, v_TextureCoordinates).rgb;
                vec4 eagleColor = texture2D(u_EagleTexture, v_TextureCoordinates);

                vec3 redHologramColor = texture2D(u_HologramTexture, redAccelerometerCoordinates).rgb;
                vec3 greenHologramColor = texture2D(u_HologramTexture, greenAccelerometerCoordinates).rgb;
                vec3 blueHologramColor = texture2D(u_HologramTexture, blueAccelerometerCoordinates).rgb;

                vec4 holoMapColor = texture2D(u_HoloMapTexture, v_TextureCoordinates);

                vec4 holoLayerColor = texture2D(u_HoloLayerTexture, v_TextureCoordinates);
                float layerVisibility = clamp(v_AccelerometerCoordinates.x * 0.5 + 0.5, 0.0, 1.0);

                // Original algorithm from mObywatel - backgroundWeight controls transparency
                float backgroundWeight = 1.0 - min(1.0, holoMapColor.r + holoMapColor.g + holoMapColor.b);

                vec3 hologramColor =
                    holoMapColor.r * redHologramColor +
                    holoMapColor.g * greenHologramColor +
                    holoMapColor.b * blueHologramColor +
                    backgroundWeight * backgroundColor;

                vec4 backgroundHologramColor = texture2D(u_BackgroundHologramTexture, v_TextureCoordinates);
                hologramColor += backgroundHologramColor.rgb * backgroundHologramColor.a;

                vec3 finalColor = eagleColor.rgb * (1.0 - holoMapColor.a * 0.5) + hologramColor * holoMapColor.a * 0.5;
                finalColor = mix(finalColor, holoLayerColor.rgb, holoLayerColor.a * layerVisibility * 0.6);

                gl_FragColor = vec4(finalColor, eagleColor.a);
            }
        `;

        // Compile shader
        function compileShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
            const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Initialize WebGL
        function initWebGL(gl, canvas) {
            const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
            gl.useProgram(program);

            const positionLocation = gl.getAttribLocation(program, 'a_position');
            const textureCoordinatesLocation = gl.getAttribLocation(program, 'a_textureCoordinates');
            const accelerometerCoordinatesLocation = gl.getAttribLocation(program, 'a_accelerometerCoordinates');

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1,
                 1, -1,
                -1,  1,
                -1,  1,
                 1, -1,
                 1,  1
            ]), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            const textureCoordinatesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordinatesBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                0, 0,
                1, 0,
                0, 1,
                0, 1,
                1, 0,
                1, 1
            ]), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(textureCoordinatesLocation);
            gl.vertexAttribPointer(textureCoordinatesLocation, 2, gl.FLOAT, false, 0, 0);

            let gammaValue = 0;
            let betaValue = 0;

            window.addEventListener('deviceorientation', (event) => {
                gammaValue = event.gamma / 90;
                betaValue = event.beta / 90;
            });

            const accelerometerCoordinatesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, accelerometerCoordinatesBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                0, 0,
                1, 0,
                0, 1,
                0, 1,
                1, 0,
                1, 1
            ]), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(accelerometerCoordinatesLocation);
            gl.vertexAttribPointer(accelerometerCoordinatesLocation, 2, gl.FLOAT, false, 0, 0);

            const u_BackgroundTextureLocation = gl.getUniformLocation(program, 'u_BackgroundTexture');
            const u_HologramTextureLocation = gl.getUniformLocation(program, 'u_HologramTexture');
            const u_HoloMapTextureLocation = gl.getUniformLocation(program, 'u_HoloMapTexture');
            const u_EagleTextureLocation = gl.getUniformLocation(program, 'u_EagleTexture');
            const u_HoloLayerTextureLocation = gl.getUniformLocation(program, 'u_HoloLayerTexture');
            const u_BackgroundHologramTextureLocation = gl.getUniformLocation(program, 'u_BackgroundHologramTexture');

            const backgroundTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, backgroundTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

            const hologramTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, hologramTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 0, 0, 255]));
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

            const holoMapTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, holoMapTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 255, 0, 255]));
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

            const eagleTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, eagleTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 0, 255]));
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

            const holoLayerTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, holoLayerTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255]));
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

            const backgroundHologramTexture = loadBackgroundHologramTexture(gl);

            gl.uniform1i(u_BackgroundTextureLocation, 0);
            gl.uniform1i(u_HologramTextureLocation, 1);
            gl.uniform1i(u_HoloMapTextureLocation, 2);
            gl.uniform1i(u_EagleTextureLocation, 3);
            gl.uniform1i(u_HoloLayerTextureLocation, 4);
            gl.uniform1i(u_BackgroundHologramTextureLocation, 5);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, backgroundTexture);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, hologramTexture);

            gl.activeTexture(gl.TEXTURE2);
            gl.bindTexture(gl.TEXTURE_2D, holoMapTexture);

            gl.activeTexture(gl.TEXTURE3);
            gl.bindTexture(gl.TEXTURE_2D, eagleTexture);

            gl.activeTexture(gl.TEXTURE4);
            gl.bindTexture(gl.TEXTURE_2D, holoLayerTexture);

            gl.activeTexture(gl.TEXTURE5);
            gl.bindTexture(gl.TEXTURE_2D, backgroundHologramTexture);

            function render() {
                gl.bindBuffer(gl.ARRAY_BUFFER, accelerometerCoordinatesBuffer);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array([
                    gammaValue, betaValue,
                    gammaValue + 1, betaValue,
                    gammaValue, betaValue + 1,
                    gammaValue, betaValue + 1,
                    gammaValue + 1, betaValue,
                    gammaValue + 1, betaValue + 1
                ]));

                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                requestAnimationFrame(render);
            }
            render();
        }

        // Main function
        function main() {
            const canvas = document.getElementById('backgroundHologramCanvas');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            const gl = canvas.getContext('webgl');
            if (!gl) {
                console.error('WebGL not supported');
                return;
            }

            initWebGL(gl, canvas);
        }

        main();
    </script>
</body>
</html>
